using Newtonsoft.Json;
using Octokit;

namespace AutoIssueSync.Sync
{
    class Program
    {
        // Class to store information of each detected issue
        public class IssueData
        {
            public string Title { get; set; }
            public string Description { get; set; }
            public string IssueType { get; set; }
            public string MethodName { get; set; }
            public string FilePath { get; set; }
        }

        static async Task Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("Usage: AutoIssueSync.Sync <issues_json_path>");
                return;
            }

            // 1. Read the `issues.json` file generated by `AutoIssueSync.Analyzer`
            var issuesFilePath = args[0];
            if (!File.Exists(issuesFilePath))
            {
                Console.WriteLine($"Error: File '{issuesFilePath}' not found.");
                return;
            }

            var issues = JsonConvert.DeserializeObject<List<IssueData>>(File.ReadAllText(issuesFilePath));
            if (issues == null || !issues.Any())
            {
                Console.WriteLine("No issues found to process.");
                return;
            }

            // 2. Configure GitHub authentication with `Octokit`
            var githubToken = Environment.GetEnvironmentVariable("GITHUB_TOKEN");
            if (string.IsNullOrWhiteSpace(githubToken))
            {
                Console.WriteLine("Error: GitHub token is not set.");
                return;
            }

            var githubClient = new GitHubClient(new ProductHeaderValue("AutoIssueSync"))
            {
                Credentials = new Credentials(githubToken)
            };

            // 3. Get repository name and owner dynamically from GitHub environment variables
            string[] repoInfo = Environment.GetEnvironmentVariable("GITHUB_REPOSITORY")?.Split('/') ?? new string[0];
            if (repoInfo.Length != 2)
            {
                Console.WriteLine("Error: Could not determine repository from GITHUB_REPOSITORY.");
                return;
            }

            string owner = repoInfo[0];
            string repo = repoInfo[1];

            Console.WriteLine($"Processing issues for repository: {owner}/{repo}");

            // 4. Retrieve existing issues from the repository
            var existingIssues = await githubClient.Issue.GetAllForRepository(owner, repo);

            // 5. Create or update issues in GitHub
            foreach (var issue in issues)
            {
                // Check if there is already an issue for this method
                var existingIssue = existingIssues
                    .FirstOrDefault(i => i.Title == issue.Title && i.Body.Contains(issue.MethodName));

                if (existingIssue != null)
                {
                    // Get existing labels and add new label if it does not exist
                    var labels = existingIssue.Labels.Select(label => label.Name).ToList();  // Convert to List<string>
                    if (!labels.Contains(issue.IssueType))
                    {
                        labels.Add(issue.IssueType);  // Add new label if not already present
                    }

                    // Prepare the updated body of the issue
                    var updatedBody = $"**Description**: {issue.Description}\n**Issue Type**: {issue.IssueType}\n**Affected Method**: {issue.MethodName}\n**File**: {issue.FilePath}";

                    // Create the IssueUpdate object to update the issue in GitHub
                    var issueUpdate = new IssueUpdate
                    {
                        Title = issue.Title,         // Update the title
                        Body = updatedBody,          // Use the updated body
                        //Labels = labels              // Use the updated list of labels (List<string>)
                    };

                    foreach (var label in labels)
                    { 
                        issueUpdate.Labels.Add(label);
                    }

                    // Update the issue with new title, body, and labels
                    await githubClient.Issue.Update(owner, repo, existingIssue.Number, issueUpdate);

                    Console.WriteLine($"Issue updated: {existingIssue.HtmlUrl}");
                }



                else
                {
                    // Create a new issue (as it does now)
                    var newIssue = new NewIssue(issue.Title)
                    {
                        Body = $"**Description**: {issue.Description}\n**Issue Type**: {issue.IssueType}\n**Affected Method**: {issue.MethodName}\n**File**: {issue.FilePath}"
                    };
                    newIssue.Labels.Add(issue.IssueType);

                    try
                    {
                        var createdIssue = await githubClient.Issue.Create(owner, repo, newIssue);
                        Console.WriteLine($"Issue created: {createdIssue.HtmlUrl}");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error creating issue '{issue.Title}': {ex.Message}");
                    }
                }
            }

            // 6. Close issues that are no longer specified in the JSON
            foreach (var existingIssue in existingIssues)
            {
                // If the issue is not found in the JSON list
                var foundInJson = issues.Any(i => i.Title == existingIssue.Title && existingIssue.Body.Contains(i.MethodName));

                if (!foundInJson)
                {
                    // Close the issue
                    var issueUpdate = new IssueUpdate
                    {
                        State = ItemState.Closed
                    };

                    await githubClient.Issue.Update(owner, repo, existingIssue.Number, issueUpdate);
                    Console.WriteLine($"Issue closed: {existingIssue.HtmlUrl}");
                }
            }
        }
    }
}
